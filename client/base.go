package client

type Msg interface {
	Sequence() uint64 // последовательный номер сообщения
	Data() []byte     // полезная нагрузка
	Timestamp() int64 //дата-время публикации сообщения в топик
	Ack() error       // подтверждение о получении сообщения, после успешного подтверждения, сообщение более не будет доставляться потребителям
	Nack() error      // возврат сообщения в топик
}

type Publisher interface {
	// публикует сообщение в топик, дожидается ответа от брокера
	Publish(msg []byte) error
	// публикует сообщение в топик, вызывает callback в момент подтверждения о доставке или получения ошибки от брокера
	PublishAsync(msg []byte, callback func(id string, err error)) error
}

type Consumer interface {
	// для чтения ошибок переподписки, закрытия подписки
	// закрывается при вызове метода Close()
	Errors() <-chan error
	// для чтения сообщений из топика
	// закрывается при вызове метода Close()
	Messages() <-chan Msg
	// закрывает канас с брокером, закрывает каналы для чтения
	Close()
}

type EventBusClient interface {
	NewPublisher(topic string) Publisher
	// регистрирует нового потребителя
	// каждый созданный через данную функцию потребитель для указанного топика будет получать одно и тоже сообщение (a.k.a RabbitMQ fanount)
	// consumerId должен быть уникален в рамках clientId клиента
	NewConsumer(topic, consumerId string) (Consumer, error)
	// регистрирует нового эксклюзивного потребителя
	// каждый созданный через данную функцию потребитель для указанного топика будет получать уникальное сообщение (стандартное поведение очереди)
	NewExclusiveConsumer(topic string) (Consumer, error)
	// для чтения ошибок от брокера: ошибок при переподключении, ошибок закрытия соединения
	// закрывается при вызове метода Close()
	Errors() <-chan error
	// останавливает всех активных потребителей, закрывает соединение с брокером
	// после вызова функции объект и все объекты порожденные через методы New* более не пригодны к использованию
	Close()
}
